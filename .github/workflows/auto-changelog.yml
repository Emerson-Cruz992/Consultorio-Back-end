name: Auto Changelog with AI

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  analyze-and-update-changelog:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper diff
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Get commit information
        id: commit_info
        run: |
          echo "author_name=${{ github.actor }}" >> $GITHUB_OUTPUT
          echo "commit_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "commit_message=$(git log -1 --pretty=%B)" >> $GITHUB_OUTPUT
          echo "timestamp=$(TZ='America/Sao_Paulo' date +'%d/%m/%Y %H:%M')" >> $GITHUB_OUTPUT
          
          # Get previous commit SHA
          if [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
            echo "previous_sha=${{ github.event.before }}" >> $GITHUB_OUTPUT
          else
            echo "previous_sha=$(git rev-parse HEAD~1 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          fi
      
      - name: Generate diff and analyze changes
        id: analyze_changes
        run: |
          # Create a temporary script to analyze changes
          cat > analyze_changes.js << 'EOF'
          const fs = require('fs');
          const { execSync } = require('child_process');
          const https = require('https');
          
          // Gemini API configuration
          const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
          
          // Check if API key exists
          if (!GEMINI_API_KEY || GEMINI_API_KEY === '' || GEMINI_API_KEY === '***') {
            console.error('WARNING: GEMINI_API_KEY is not set or is masked');
            console.error('Make sure GEMINI_API_KEY secret is properly configured in repository settings');
          } else {
            console.error('API Key length:', GEMINI_API_KEY.length);
            console.error('API Key first 10 chars:', GEMINI_API_KEY.substring(0, 10) + '...');
          }
          
          const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;
          
          async function callGeminiAPI(prompt) {
            return new Promise((resolve, reject) => {
              const data = JSON.stringify({
                contents: [{
                  parts: [{
                    text: prompt
                  }]
                }],
                generationConfig: {
                  temperature: 0.4,
                  maxOutputTokens: 500
                }
              });
              
              const options = {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': data.length
                }
              };
              
              const req = https.request(GEMINI_API_URL, options, (res) => {
                let responseData = '';
                
                res.on('data', (chunk) => {
                  responseData += chunk;
                });
                
                res.on('end', () => {
                  try {
                    console.error('API Response Status:', res.statusCode);
                    console.error('API Response Headers:', JSON.stringify(res.headers));
                    
                    // Log first 500 chars of response for debugging
                    console.error('API Response (first 500 chars):', responseData.substring(0, 500));
                    
                    const response = JSON.parse(responseData);
                    
                    // Check for error in response
                    if (response.error) {
                      console.error('API Error:', JSON.stringify(response.error));
                      reject(new Error(`Gemini API Error: ${response.error.message || 'Unknown error'}`));
                      return;
                    }
                    
                    if (response.candidates && response.candidates[0]?.content?.parts?.[0]?.text) {
                      resolve(response.candidates[0].content.parts[0].text);
                    } else {
                      console.error('Unexpected API response structure:', JSON.stringify(response).substring(0, 500));
                      reject(new Error('Invalid API response structure'));
                    }
                  } catch (error) {
                    console.error('Failed to parse API response:', error.message);
                    reject(error);
                  }
                });
              });
              
              req.on('error', (error) => {
                console.error('Request error:', error.message);
                reject(error);
              });
              
              req.write(data);
              req.end();
            });
          }
          
          async function analyzeChanges() {
            const previousSha = process.env.PREVIOUS_SHA;
            const currentSha = process.env.CURRENT_SHA;
            
            if (!previousSha) {
              console.log('CHANGE_TYPE=major');
              console.log('DESCRIPTION=Commit inicial do projeto');
              return;
            }
            
            try {
              // Get file diff
              const diff = execSync(`git diff ${previousSha}..${currentSha} --stat`, { encoding: 'utf8' });
              const detailedDiff = execSync(`git diff ${previousSha}..${currentSha}`, { encoding: 'utf8', maxBuffer: 1024 * 1024 * 10 });
              
              // Get list of changed files
              const changedFiles = execSync(`git diff --name-only ${previousSha}..${currentSha}`, { encoding: 'utf8' })
                .split('\n')
                .filter(f => f);
              
              // Truncate diff if too large (> 30000 chars)
              const truncatedDiff = detailedDiff.length > 30000 
                ? detailedDiff.substring(0, 30000) + '\n... [diff truncated]'
                : detailedDiff;
              
              const prompt = `Você é um analisador de código especializado. Analise as mudanças no código abaixo e forneça uma resposta EXATAMENTE neste formato JSON:

          {
            "change_type": "major|minor|patch",
            "description": "descrição concisa das mudanças"
          }

          Regras de classificação:
          - "major": Mudanças drásticas, refatoração completa, mudança de arquitetura, breaking changes
          - "minor": Mudanças consideráveis, novas funcionalidades, melhorias significativas
          - "patch": Pequenas correções, ajustes menores, typos, comentários

          Para "patch", a descrição deve ter NO MÁXIMO 2 linhas curtas.
          Para "minor" e "major", descreva as principais mudanças de forma clara e objetiva.

          Arquivos alterados:
          ${changedFiles.join(', ')}

          Estatísticas:
          ${diff}

          Diff detalhado:
          \`\`\`
          ${truncatedDiff}
          \`\`\`

          Responda APENAS com o JSON, sem explicações adicionais.`;
              
              const response = await callGeminiAPI(prompt);
              
              // Parse response
              try {
                // Extract JSON from response (in case there's extra text)
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                  const analysis = JSON.parse(jsonMatch[0]);
                  console.log(`CHANGE_TYPE=${analysis.change_type}`);
                  console.log(`DESCRIPTION=${analysis.description.replace(/\n/g, ' ')}`);
                } else {
                  throw new Error('No JSON found in response');
                }
              } catch (parseError) {
                // Fallback if parsing fails
                console.log('CHANGE_TYPE=minor');
                console.log(`DESCRIPTION=${response.substring(0, 200).replace(/\n/g, ' ')}`);
              }
              
            } catch (error) {
              console.error('Error analyzing changes:', error.message);
              // Fallback analysis based on file count
              const changedFiles = execSync(`git diff --name-only ${previousSha}..${currentSha}`, { encoding: 'utf8' })
                .split('\n')
                .filter(f => f);
              
              if (changedFiles.length > 10) {
                console.log('CHANGE_TYPE=major');
                console.log('DESCRIPTION=Múltiplas alterações significativas no projeto');
              } else if (changedFiles.length > 3) {
                console.log('CHANGE_TYPE=minor');
                console.log('DESCRIPTION=Várias melhorias e ajustes no código');
              } else {
                console.log('CHANGE_TYPE=patch');
                console.log('DESCRIPTION=Pequenos ajustes e correções');
              }
            }
          }
          
          analyzeChanges().catch(console.error);
          EOF
          
          # Run the analysis script
          ANALYSIS_OUTPUT=$(GEMINI_API_KEY="${{ secrets.GEMINI_API_KEY }}" \
            PREVIOUS_SHA="${{ steps.commit_info.outputs.previous_sha }}" \
            CURRENT_SHA="${{ steps.commit_info.outputs.commit_sha }}" \
            node analyze_changes.js)
          
          # Extract values from output
          CHANGE_TYPE=$(echo "$ANALYSIS_OUTPUT" | grep "CHANGE_TYPE=" | cut -d'=' -f2)
          DESCRIPTION=$(echo "$ANALYSIS_OUTPUT" | grep "DESCRIPTION=" | cut -d'=' -f2-)
          
          echo "change_type=${CHANGE_TYPE:-minor}" >> $GITHUB_OUTPUT
          echo "description=${DESCRIPTION:-Atualização no código}" >> $GITHUB_OUTPUT
      
      - name: Calculate version
        id: version
        run: |
          # Check if README.md exists
          if [ ! -f README.md ]; then
            echo "# Changelog do Projeto" > README.md
            echo "" >> README.md
            echo "## Histórico de Versões" >> README.md
            echo "" >> README.md
            CURRENT_VERSION="1.0.0"
          else
            # Check if this commit already has a version (re-run scenario)
            CURRENT_SHA="${{ steps.commit_info.outputs.commit_sha }}"
            EXISTING_VERSION=$(grep -B2 "Commit: ${CURRENT_SHA:0:7}" README.md | grep -oP 'Versão \K[0-9]+\.[0-9]+(\.[0-9]+)?' | head -1 || echo "")
            
            if [ -n "$EXISTING_VERSION" ]; then
              echo "🔄 Re-run detected: Using existing version $EXISTING_VERSION for commit ${CURRENT_SHA:0:7}"
              CURRENT_VERSION="$EXISTING_VERSION"
            else
              # Extract last version from README.md
              LAST_VERSION=$(grep -oP 'Versão \K[0-9]+\.[0-9]+(\.[0-9]+)?' README.md | tail -1 || echo "0.0.0")
              
              if [ -z "$LAST_VERSION" ]; then
                LAST_VERSION="0.0.0"
              fi
              
              # Split version components
              MAJOR=$(echo $LAST_VERSION | cut -d. -f1)
              MINOR=$(echo $LAST_VERSION | cut -d. -f2)
              PATCH=$(echo $LAST_VERSION | cut -d. -f3)
              
              # Handle missing patch version
              if [ -z "$PATCH" ]; then
                PATCH="0"
              fi
              
              # Calculate new version based on change type
              CHANGE_TYPE="${{ steps.analyze_changes.outputs.change_type }}"
              
              if [ "$CHANGE_TYPE" = "major" ]; then
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                CURRENT_VERSION="$MAJOR.$MINOR"
              elif [ "$CHANGE_TYPE" = "minor" ]; then
                MINOR=$((MINOR + 1))
                PATCH=0
                CURRENT_VERSION="$MAJOR.$MINOR"
              else
                PATCH=$((PATCH + 1))
                CURRENT_VERSION="$MAJOR.$MINOR.$PATCH"
              fi
            fi
          fi
          
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
      
      - name: Update README.md
        run: |
          # Check if this is a re-run (workflow re-execution)
          IS_RERUN="false"
          CURRENT_SHA="${{ steps.commit_info.outputs.commit_sha }}"
          
          # Check if README exists and if current commit is already documented
          if [ -f README.md ]; then
            # Extract the SHA from commit messages in README (if they exist)
            # Look for pattern like "Commit: abc123..." in the changelog
            if grep -q "Commit: ${CURRENT_SHA:0:7}" README.md; then
              IS_RERUN="true"
              echo "🔄 Re-run detected for commit ${CURRENT_SHA:0:7}"
            fi
          fi
          
          # Create the new entry
          cat > new_entry.tmp << EOF
          
          ### Versão ${{ steps.version.outputs.version }} - ${{ steps.commit_info.outputs.author_name }} - ${{ steps.commit_info.outputs.timestamp }}
          
          ${{ steps.analyze_changes.outputs.description }}
          
          _Commit: ${CURRENT_SHA:0:7}_
          
          EOF
          
          if [ "$IS_RERUN" = "true" ] && [ -f README.md ]; then
            echo "♻️ Updating existing entry for version ${{ steps.version.outputs.version }}"
            
            # Remove the last version entry (between the current version header and the next version header or end of file)
            # This is more complex but handles re-runs properly
            awk -v version="${{ steps.version.outputs.version }}" '
              BEGIN { skip = 0; buffer = "" }
              /^### Versão/ {
                if ($3 == version) {
                  skip = 1
                  next
                } else if (skip == 1) {
                  skip = 0
                  # Print the new entry before the next version
                  while ((getline line < "new_entry.tmp") > 0) print line
                  close("new_entry.tmp")
                }
              }
              { 
                if (skip == 0) print 
              }
              END {
                if (skip == 1) {
                  # If we were skipping until EOF, add the new entry at the end
                  while ((getline line < "new_entry.tmp") > 0) print line
                  close("new_entry.tmp")
                }
              }
            ' README.md > README.tmp
            
            # If the version wasn't found (edge case), just add it normally
            if ! grep -q "### Versão ${{ steps.version.outputs.version }}" README.tmp; then
              rm README.tmp
              # Insert new entry after the "Histórico de Versões" header
              awk '/## Histórico de Versões/ {print; getline; print; while((getline line < "new_entry.tmp") > 0) print line; close("new_entry.tmp")} !/## Histórico de Versões/ || NR==1' README.md > README.tmp
            fi
            
            mv README.tmp README.md
          elif [ -f README.md ]; then
            echo "➕ Adding new entry for version ${{ steps.version.outputs.version }}"
            
            if grep -q "## Histórico de Versões" README.md; then
              # Insert new entry after the "Histórico de Versões" header
              awk '/## Histórico de Versões/ {print; getline; print; while((getline line < "new_entry.tmp") > 0) print line; close("new_entry.tmp")} !/## Histórico de Versões/ || NR==1' README.md > README.tmp
              mv README.tmp README.md
            else
              # Append changelog section to README
              echo "" >> README.md
              echo "## Histórico de Versões" >> README.md
              cat new_entry.tmp >> README.md
            fi
          else
            # Create new README
            echo "# Changelog do Projeto" > README.md
            echo "" >> README.md
            echo "## Histórico de Versões" >> README.md
            cat new_entry.tmp >> README.md
          fi
          
          rm new_entry.tmp
      
      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Add the README changes first
          git add README.md
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            # Commit the changes
            git commit -m "📝 Auto-update changelog: v${{ steps.version.outputs.version }}"
            
            # Pull and merge latest changes
            git fetch origin main
            git merge origin/main --no-edit || {
              echo "Merge conflict detected, attempting to resolve..."
              # In case of conflict, prefer our version (the newly generated changelog)
              git checkout --ours README.md
              git add README.md
              git commit --no-edit || true
            }
            
            # Try to push with retry logic
            RETRY_COUNT=0
            MAX_RETRIES=3
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if git push; then
                echo "✅ Push successful!"
                break
              else
                echo "⚠️ Push failed, attempting retry $((RETRY_COUNT + 1))/$MAX_RETRIES"
                git pull --rebase=false --strategy=ours --no-edit
                RETRY_COUNT=$((RETRY_COUNT + 1))
                sleep 2
              fi
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "❌ Failed to push after $MAX_RETRIES attempts"
              exit 1
            fi
          fi
